function [ pforce ] = fmGetFrame(fid, header, varargin)
%parseFM Summary of this function goes here
%   The function reads binary files containing a N x N x F 
%   force matrix generated by FDA gromacs, where N is the number of 
%   atoms in the system and F the number of frames. Detailed information 
%   about the header and file format structure is found in the code
%   within this function.
%   
%   Input parameter: 
%       start: First frame of the output forces
%       end: First frame of the output forces
%       skip: Skip the every nth frame 
%       filter: List of atoms to parse forces from (e.g. [1 2 3 4 5 ... N] or [1:1:N] )
%   
%   Output parameter:
%       pforce: Struct containing dimension of force matrix (fmdim), the
%       index matrix (index_matrix), timesteps and the results. The results comprise 
%       the index array, force(pforce)- and interaction matrix(interaction).
%
%   Example for call:   
%       pforce=parseFM('$MATLAB-Repo&\', 'filter', [1:50]); 
%       pforce=parseFM('$MATLAB-Repo&\', 'filter', [1:50], 'start', 10, 'end', 100, 'skip', 2, 'progress', 'raw');
%       When using option 'raw' access variable with e.g. pforce{1}.pforce
%
%   See also:           
%       parseTRR
%   Dependencies:       
%       parseArgs.m, progressbar.m 
%
%   Created:            Reiner J. Ribarics
%   Last modified:      $LastChangedDate: 2011-05-04 14:35:21 +0200 (Mi, 04 Mai 2011) $
%   Version:            $Id: parseTRR.m 6 2011-05-04 12:35:21Z reiner $


%%% START Subroutines %%%
    % Read binary block. File position indicator has to
    % be positioned to the first bit of a block that is usually
    % after the <end_of_block> entry of the header.
    function block = readBinaryBlock(fid, header)
        % Read block
        block = struct();
        block.timestep    = fread(fid, 1, header.sizeof_int);
        block.entries     = fread(fid, 1, header.sizeof_int);
        block.ID_list     = fread(fid, header.fmdim, header.sizeof_int);
        %block.index_array = fread(fid, block.entries, header.sizeof_int);
        block.index_array = fread(fid, block.entries, 'uint');
        block.pforce      = fread(fid, block.entries, header.sizeof_real, 'n');
        block.interaction = fread(fid, block.entries, 'char*1');
        block.endofblock  = fread(fid, 1, 'int');
        
        % Check magic number
        if block.endofblock ~= fmMagic
            error('File seems to be corrupted!');
        end 

        % C starts counting at zero, but R and MATLAB at 1
        % Gromacs also starts counting at 1, so these now correspond to the
        % Gromacs index file. Notes for VMD users: it starts counting at
        % zero as well!
        block.ID_list     = shiftdim(block.ID_list,1) + 1;
        block.index_raw = block.index_array;
        block.index_array = block.index_array + 1;
        
    end
%%% END Subroutines %%%

% Input handling
argStruct = struct('verbose', false, ...
                   'progress', false) ; 
               
argStruct = parseArgs(varargin, argStruct, {'verbose'; 'progress'}); % The cell specifies optional arguments that have to be included in argStruct
fmMagic = -280480;

% Output relevant data to command line
if (argStruct.verbose) 
    fprintf('; Forcemat version %1.1f\n', header.forcemat_version);
    fprintf('%s\n', header.content)
    fprintf('; Matrix dimension %i x %i entries\n' , header.fmdim, header.fmdim);
    fprintf('; Matrix contains %i blocks\n' , nframes);
end 

% Initialize progressbar
if (argStruct.progress)
    set(0,'defaulttextinterpreter','none'); % Turn off Tex interpreter for better visualisation
    progressbar(['Reading force matrix ']);
end

% Read blocks     
% Get pair wise forces and interactions             
block   = readBinaryBlock(fid, header);
data    = horzcat(double(block.index_array), double(block.pforce), double(block.interaction));
sdata   = data; %sortrows(data,1);
[i, j]  = ix2xy(sdata(:,1), header.fmdim);
result  = [i, j, sdata(:,2), sdata(:,3), sdata(:,1)];
        
% When the option 'verbose' is given, additional blockwise information about interactions will be printed to the command line
if (argStruct.verbose) 
    fprintf('\n');
    fprintf('---- Block %i ----\n', i);
    fprintf('; Number of bonded interactions: %i\n', numel(find(block.interaction == 1)));
    fprintf('; Number of angle interactions: %i\n',numel(find(block.interaction == 2)));
    fprintf('; Number of dihedral interactions: %i\n', numel(find(block.interaction == 3)));
    fprintf('; Number of VdW interactions: %i\n', numel(find(block.interaction == 5)));
    fprintf('; Number of coulomb interactions: %i\n',numel(find(block.interaction == 6)));
    fprintf('; Number of cumulated interactions: %i\n',numel(find(block.interaction == 7)));
end 

pforce = struct('fmdim', header.fmdim, 'result', result, 'timestep', block.timestep, 'debug', block);

end 

%{
Header information
-----------------------------------------------------------------------------
The force index_matrix file format (version 1.2)
The .fm file contains a 13-line ASCII header followed by a number of binary
data frames, each frame represents one write step. The following entries in
the header are allowed, entries need to be of the form label=value:
    • version (char*) - .fm file version
    • groupname (char*) - index_array group for which forces were written out
    • writefreq (int) - output frequence (in simulation steps)
    • nsteps (int) - number of frames in the file. This is an estimate, don’t
    trust this value!
    • sysanr (int) - number of atoms in the whole system, including water
    and ions
    • fmdim (int) - dimension of the force index_matrix, what equals to the number
    of atoms for which forces were written out
    • intsize (int) - the sizeof(int) for the hardware the file was written
    on
    • realsize (int) - the sizeof(real) for the hardware the file was written
    on
-----------------------------------------------------------------------------

Data Block organisation
-----------------------------------------------------------------------------
Each of the following binary blocks contains an array of forces and the according
index_array and interaction arrays. The index_array array stores the index_array in the
force index_matrix (according to a symmetric atoms × atoms index_matrix) and the interaction
array the interaction type (bond, angle, dihedral, VdW or Coulomb).

datatype    count       description
int         1           Current write step
int         1           Number of entries in the force-index_matrix (entries)
int*        fmdim       Atom IDs of the atoms in the force index_matrix
int*        entries     The index_array array
real*       entries     The forces
char*       entries     The interaction type between each two atoms. This can be bond | angle | dihedral | Vdw | Coulomb.
int         1           Each block is closed by writing an integer with value NEW ENTRY

Interaction values: 
• bond      = 1
• angle     = 2
• dihedrals = 3
• VdW       = 5 
• Coulomb   = 6
• cumulated = 7

The n*n symmetrical index_matrix of pairwise forces will be primarily populated 
with zeroes and therefore be classified as a sparse index_matrix. The data is 
stored by SparseM in the commonly used Compressed Row Storage (CRS) format.
The whole index_matrix is used, the upper triangular part for storing VdW forces
and the lower part is allocated for Coulomb forces.

Compressed Row Storage (CRS)
-----------------------------------------------------------------------------
The Compressed Row Storage (CRS) format puts the subsequent nonzeros of the 
index_matrix rows in contiguous memory locations. Assuming we have a nonsymmetric 
sparse index_matrix, we create vectors: one for floating-point numbers (val), 
and the other two for integers (col_ind, row_ptr). The val vector stores the
values of the nonzero elements of the index_matrix, as they are traversed in a 
row-wise fashion. The col_ind vector stores the column index_arrayes of the 
elements in the val vector.
-----------------------------------------------------------------------------
%}
