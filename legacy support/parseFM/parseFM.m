function [pforce] = parseFM(filename, varargin)
%parseFM Parse binary *.fm file of pair wise atom-atom interactions generated
%by FDA Gromacs (W. Stacklies)
%
%   The function reads binary files containing a N x N x F force matrix 
%   generated by FDA gromacs. N is the number of atoms in the system and F 
%   the number of frames. This binary file is outdated and was replaced by 
%   another more versatile file format. Use the fmParse toolbox to read the
%   new file format developed by Bogdan Costescou. 
%   
%   Input params        Description                                     Default value
%       start           First frame of the output forces
%       end             First frame of the output forces
%       skip            Skip the every nth frame 
%       filter          List of atoms to parse forces from (e.g. [1 2 3 4 5 ... N] or [1:1:N] )
%   
%   Output parameter:
%       pforce: Struct containing dimension of force matrix (fmdim), the
%       index matrix (index_matrix), timesteps and the results. The results comprise 
%       the index array, force(pforce)- and interaction matrix(interaction).
%
%   Example for call:   
%       pforce=parseFM('$MATLAB-Repo&\', 'filter', [1:50]); 
%       pforce=parseFM('$MATLAB-Repo&\', 'filter', [1:50], 'start', 10, 'end', 100, 'skip', 2, 'progress', 'raw');
%       When using option 'raw' access variable with e.g. pforce{1}.pforce
%
%   See also:           
%       parseTRR
%   Dependencies:       
%       parseArgs.m, progressbar.m 
%
%   Created:            Reiner J. Ribarics
%   Last modified:      $LastChangedDate: 2011-05-04 14:35:21 +0200 (Mi, 04 Mai 2011) $
%   Version:            $Id: parseTRR.m 6 2011-05-04 12:35:21Z reiner $


%-----------------------------START Subroutines-------------------------------%
    % Read binary block. File position indicator has to
    % be positioned to the first bit of a block that is usually
    % after the <end_of_block> entry of the header.
    function block = readBinaryBlock(fid, header)
        % Read block
        block = struct();
        block.timestep    = fread(fid, 1, header.sizeof_int);
        block.entries     = fread(fid, 1, header.sizeof_int);
        block.ID_list     = fread(fid, header.fmdim, header.sizeof_int);
        %block.index_array = fread(fid, block.entries, header.sizeof_int);
        block.index_array = fread(fid, block.entries, 'uint'); %FIXME: let this be flexible, but only use unsigned integers!
        block.pforce      = fread(fid, block.entries, header.sizeof_real, 'n');
        block.interaction = fread(fid, block.entries, 'char*1');
        block.endofblock  = fread(fid, 1, 'int');
        
        % Check magic number
        if block.endofblock ~= fmMagic
            error('File seems to be corrupted!');
        end 

        % C starts counting at zero, but R and MATLAB at 1
        % Gromacs also starts counting at 1, so these now correspond to the
        % Gromacs index file. Notes for VMD users: it starts counting at
        % zero as well!
        block.ID_list     = shiftdim(block.ID_list,1) + 1;
        block.index_array = block.index_array + 1;
    end

    % Count the number of blocks in a file. Returns the number of blocks. After
    % iterating over all data blocks the file pointer is set back to the original
    % position.
    function frames = fmCountBlocks(fid, header)
        sizeof_int = header.intsize;
        sizeof_real = header.realsize;
        sizeof_char = 1;
        frames = 0;
        
        % Jump to EOF to get file's bytesize   
        fseek(fid, 0, 'eof');
        EOF = ftell(fid);
        % Set file position indicator back to beginning of data blocks
        % right after the header
        fseek(fid, header.headsize, 'bof');
        % Filesize will get incremented by each jump and compared to EOF
        filesize = header.headsize;

        while (1)
            if (EOF - filesize == 3)
                break
            end 
            iter  = fread(fid, 1, header.sizeof_int); % read timestep
            entries = fread(fid, 1, header.sizeof_int); % read number of entries

            offset = sizeof_int * header.fmdim + entries * (sizeof_int + sizeof_real + sizeof_char);
            % Three times four bytes (12) equals the current writestep, 
            % the number of entries and the magic number (aka NEW_ENTRY)
            filesize = filesize + uint64(offset + 3*sizeof_int); 
            if (filesize >= EOF)
                error('Calculated file size exceeds EOF. File may be corrupted!');
            end 
            fseek(fid, offset, 'cof');

            % Check for possible file corruption
            magic_number = fread(fid, 1, header.sizeof_int);
            if magic_number ~= fmMagic
                warning('File corrupted, only counted the first %i frames', frames);
            end
            frames = frames + 1;
        end 
        fseek(fid, header.headsize, 'bof'); % Reset the file position indicator to the beginning of the data blocks
    end 

    function fm_header = fmHeader(fid)    
        % FIXME: rewrite header handling to allow for flexible headers! 
        % Read 13 lines that correspond to the header
        line                    = fgets(fid);
        forcemat_version        = cell2mat(textscan(fgets(fid), '; Forcemat version %8.1f'));
        content                 = strtrim(fgets(fid));
        index_matrix_dimension  = cell2mat(textscan(fgets(fid), '; Matrix dimension %f'));
        version                 = fgets(fid);
        groupname               = textscan(fgets(fid), 'groupname=%s');
        write_frequency         = cell2mat(textscan(fgets(fid), 'writefreq=%f'));
        nsteps                  = cell2mat(textscan(fgets(fid), 'nsteps=%f'));
        sysanr                  = cell2mat(textscan(fgets(fid), 'sysanr=%f'));
        fmdim                   = cell2mat(textscan(fgets(fid), 'fmdim=%f'));
        intsize                 = cell2mat(textscan(fgets(fid), 'intsize=%f'));
        realsize                = cell2mat(textscan(fgets(fid), 'realsize=%f'));
        line                    = fgets(fid);
        headsize                = double(ftell(fid));

        % Set int and real size for reading binary blocks            
        if (intsize == 4)
            sizeof_int = '*int';
        elseif (intsize == 8)
            sizeof_int = '*int64';
        end
        if (realsize == 4) 
            sizeof_real = '*single';
            precision   = 'single';
        elseif (realsize == 8)
            sizeof_real = '*double';
            precision   = 'double';
        end 

        % Group header information
        fm_header = struct('forcemat_version', forcemat_version,... 
                           'index_matrix_dimension', index_matrix_dimension,...
                           'groupname' ,groupname,...
                           'write_frequency', write_frequency,...
                           'nsteps', nsteps,...
                           'sysanr', sysanr,...
                           'fmdim', fmdim,...
                           'intsize', intsize,...
                           'realsize', realsize,...
                           'sizeof_int', sizeof_int,...
                           'sizeof_real', sizeof_real,...
                           'headsize', headsize,... 
                           'content', content,...
                           'precision', precision);
        
       % Check forcemat version
        if ((fm_header.forcemat_version) ~= 1.2 && (fm_header.forcemat_version ~= 1.5))
            if (fm_header.forcemat_version ~= 1.5)
                error('Forcemat version %1.1f is not supported', fm_header.forcemat_version);
            end 
        end
    end 

    function fid = fmOpen(filename)
        fid = fopen(filename,'r');

        if (fid < 0) % Does the given filename exist?
            error('Could not open file "%s"', filename);
        end
    end

    function fmJumpToFrame(targetFrame)
        targetFrame = targetFrame - 1;
        
        if (targetFrame == 0)
            fseek(fid, header.headsize, 'bof');
            return
        end 
        
        sizeof_int = header.intsize;
        sizeof_real = header.realsize;
        sizeof_char = 1;
        
        % Jump to EOF to get file's bytesize   
        fseek(fid, 0, 'eof');
        EOF = ftell(fid);
        % Set file position indicator back to beginning of data blocks
        % right after the header
        fseek(fid, header.headsize, 'bof');
        % Filesize will get incremented by each jump and compared to EOF
        filesize = header.headsize;

        jtf_frames = 0;
        while (1)
            if (EOF - filesize == 3)
                break
            end
            iter    = fread(fid, 1, header.sizeof_int); % read timestep
            entries = fread(fid, 1, header.sizeof_int); % read number of entries
            offset = sizeof_int * header.fmdim + entries * (sizeof_int + sizeof_real + sizeof_char);
            
            % Three times four bytes (12) equals the current writestep, 
            % the number of entries and the magic number (aka NEW_ENTRY)
            filesize = filesize + uint64(offset + 12);
            if (filesize >= EOF)
                error('Calculated file size exceeds EOF. File may be corrupted!');
            end 
            fseek(fid, offset, 'cof');

            % Check for possible file corruption
            magic_number = fread(fid, 1, header.sizeof_int);
            if magic_number ~= fmMagic
                error('File corrupted, only counting the first %i frames', jtf_frames);
            end
            
            % Break loop when jump to target frame is finished
            jtf_frames = jtf_frames + 1;
            if (jtf_frames == targetFrame)
                break
            end 
        end 
    end 

    function fmJumpOneFrame(header)
        sizeof_char = 1;
        iter    = fread(fid, 1, header.sizeof_int); % Read timestep
        entries = fread(fid, 1, header.sizeof_int); % Read number of entries
        offset  = header.intsize * header.fmdim + entries * (header.intsize + header.realsize + sizeof_char);
        % Three times four bytes (12) equals the current writestep, 
        % the number of entries and the magic number (aka NEW_ENTRY)
        fseek(fid, offset, 'cof');
        
        magic_number = fread(fid, 1, header.sizeof_int);
        if magic_number ~= fmMagic
            error('Wrong magic number. File may be corrupted!');
        end
    end     

    function [sm_pforce, sm_interaction] = fmGetTimeStep(block, filter)
        % Sort data
        data  = horzcat(double(block.index_array), double(block.pforce), double(block.interaction));
        sdata = sortrows(data,1);

        % Filter contains the output order 
        sfilter = sort(filter);
        subset  = intersect(sdata(:,1), sfilter); % Subset with indices to search for. What values do they have in common? Intersect will find out.
        ssubset = sort(subset);

        % When no indicies to search for are given, check data integrity.
        if isempty(argStruct.atomlist)
            if (numel(intersect(sdata(:,1), ssubset)) ~= numel(sdata(:,1)))
                error('Error in block %i. Some indices out of range.');
            end 
        end 

        stencil = ismember(sfilter, ssubset); % project sm_pforce_subset onto stencil of sfilter   
        f       = ismember(sdata(:,1), ssubset);

        % Last but not least you want an array (sm_pforce) with the entries in filter
        sm_pforce        = zeros(N^2, 1, header.precision); % Same as above but with loads of zeros ;)
        sm_interaction   = uint8(zeros(N^2, 1));
        sm_pforce(stencil)      = sdata(f, 2);
        sm_interaction(stencil) = sdata(f, 3);       
    end

    function [sm_pforce, sm_interaction, sm_index_array] = fmGetTimeStepRaw(block, filter)
        % Sort data
        data  = horzcat(double(block.index_array), double(block.pforce), double(block.interaction));
        sdata = sortrows(data,1);

        % Filter contains the output order 
        sfilter = sort(filter);
        subset  = intersect(sdata(:,1), sfilter); % Subset with indices to search for. What values do they have in common? Intersect will find out.
        ssubset = sort(subset);

        % When no indicies to search for are given, check data integrity.
        if isempty(argStruct.atomlist)
            if (numel(intersect(sdata(:,1), ssubset)) ~= numel(sdata(:,1)))
                error('Error in block %i. Some indices out of range.');
            end 
        end
        
        f = ismember(sdata(:,1), ssubset);

        % Last but not least you want an array (sm_pforce) with the entries in filter
        sm_index_array = sdata(f, 1);
        sm_pforce      = sdata(f, 2);
        sm_interaction = sdata(f, 3);
    end 
%------------------------------END Subroutines--------------------------------%

% Check for necessary functions
if (exist('parseArgs.m', 'file') == 0) || (exist('progressbar.m', 'file') == 0)
    error('Your are missing either parseArgs.m or progressbar.m. You can download it on "http://www.mathworks.com"');
end

% Input handling
[ path file ext ] = fileparts( filename );
argStruct = struct('atomlist',  [], ...
                   'start',   1, ...
                   'end',     0, ...
                   'skip',    1, ...
                   'verbose', false, ...
                   'progress', false, ...
                   'speed', 0, ...
                   'raw', false) ; 
               
argStruct = parseArgs(varargin, argStruct, {'verbose'; 'progress'; 'raw'}); % The cell specifies optional arguments that have to be included in argStruct

fid     = fmOpen(filename);   
fmMagic = -280480;
header  = fmHeader(fid);

% Check for integer overflow
maxIntegerValue = 4294967295;
if (header.fmdim > sqrt(maxIntegerValue))
    warning('Warning: your system size very large. Integer overflow will cause corrupt atom indexing!');
end

if (argStruct.speed > 0)
    nframes = argStruct.speed;
else
    nframes = fmCountBlocks(fid, header);  
end

% Checking sense of input
if (sign(argStruct.end) < 0) || (sign(argStruct.start) < 1) || (sign(argStruct.skip) < 0)
    error('Check your input of start, end or skip!');
end

if (argStruct.end)
    if argStruct.start > argStruct.end
        error('Start frame is greater than end frame!'); 
    else
        if argStruct.end > nframes
            error('The trajectory contains %i nframes. You entered %i!', nframes, argStruct.end);
        else 
            fmJumpToFrame(argStruct.start)
            readnFrames = (argStruct.end - argStruct.start + 1);
        end 
    end
else 
    readnFrames = nframes - (argStruct.start - 1);
end

% Output relevant data to command line
if (argStruct.verbose) 
    fprintf('; Forcemat version %1.1f\n', header.forcemat_version);
    fprintf('%s\n', header.content)
    fprintf('; Matrix dimension %i x %i entries\n' , header.fmdim, header.fmdim);
    fprintf('; File contains %i blocks\n' , nframes);
end 

% Define filter for searching the index_matrix
if isempty(argStruct.atomlist)
    % No filter specified. atom_list filled with all atoms that are
    % continously named
    N = header.index_matrix_dimension; 
    atom_list = 1:1:N;
else 
    N = length(argStruct.atomlist);
    atom_list = sort(argStruct.atomlist);
end 

% Generate a NxN symmetrical index_matrix from the atom list that contains
% a subset of indices we want to search for int the *.fm file.
x = ones(1, N^2);
for i = 0:N-1
    s = 1 + i * N;
    e = N + i * N;
    x(s:e) = x(s:e) .* atom_list(i+1); 
end

index_matrix = reshape(xy2ix(x, repmat(atom_list, 1, N), header.fmdim), N, N);
filter = reshape(index_matrix, 1, numel(index_matrix));

% Memory management
[user sys]  = memory;
max_entries = user.MaxPossibleArrayBytes / header.realsize;
max_atoms   = fix(sqrt(max_entries / readnFrames));

if N > max_atoms
    error('Not enought memory to store the force matrix trajectory in RAM!');
end 

% Memory allocation
if (argStruct.raw == true)
    results          = cell(fix(readnFrames/argStruct.skip), 1);
else
    pforce           = zeros(N, N, fix(readnFrames/argStruct.skip), header.precision); % ( index X index X frames )
    interaction      = uint8(zeros(N, N, fix(readnFrames/argStruct.skip)));
end

timesteps = zeros(readnFrames, 1);

% Initialize progressbar
if (argStruct.progress)
    set(0,'defaulttextinterpreter','none'); % Turn off Tex interpreter for better visualisation
    progressbar(['Reading force matrix ', strcat(file, ext)]);
end 

% Read blocks
ii = 1;
for i = 1:readnFrames
    if (mod(i, argStruct.skip) == 0) % Skipping frames
        % Get pair wise forces and interactions             
        block = readBinaryBlock(fid, header);
        timesteps(i) = block.timestep;
        
        if (argStruct.raw == true)
            [sm_pforce, sm_interaction, sm_index_array] = fmGetTimeStepRaw(block, filter);

            results{ii} = struct('index_array', sm_index_array, ...
                                 'pforce', sm_pforce, ...
                                 'interaction', sm_interaction);
        else
            [sm_pforce, sm_interaction] = fmGetTimeStep(block, filter);
            % Reshaping one dimensional arrays into two dimensional matrix
            pforce(:,:,ii)      = reshape(sm_pforce, N, N);
            interaction(:,:,ii) = reshape(sm_interaction, N, N);
        end

        % When the option 'verbose' is given, additional blockwise information about interactions will be printed to the command line
        if (argStruct.verbose) 
            fprintf('\n');
            fprintf('---- Block %i ----\n', i);
            fprintf('; Number of bonded interactions: %i\n', numel(find(block.interaction == 1)));
            fprintf('; Number of angle interactions: %i\n',numel(find(block.interaction == 2)));
            fprintf('; Number of dihedral interactions: %i\n', numel(find(block.interaction == 3)));
            fprintf('; Number of VdW interactions: %i\n', numel(find(block.interaction == 5)));
            fprintf('; Number of coulomb interactions: %i\n',numel(find(block.interaction == 6)));
            fprintf('; Number of cumulated interactions: %i\n',numel(find(block.interaction == 7)));
        end 
        
        clear block
        ii = ii + 1;
        
        % Calculate percentage of job and passing it to progessbar
        if (argStruct.progress)
            progressbar(i/readnFrames);
        end
        
    elseif (i == readnFrames)
        % Send finishing signal to progessbar
        if (argStruct.progress)
            progressbar(1);
        end 
    else
        fmJumpOneFrame(header);
    end
end 

if (argStruct.raw == true)
    pforce = struct('fmdim', header.fmdim, 'index_matrix', index_matrix, 'results', results, 'timesteps', timesteps);
else 
    pforce = struct('fmdim', header.fmdim, 'index_matrix', index_matrix, 'interaction', interaction, 'pforce', pforce, 'timesteps', timesteps);
end 

fclose(fid);

end 

%{
Header information
-----------------------------------------------------------------------------
The force index_matrix file format (version 1.2)
The .fm file contains a 13-line ASCII header followed by a number of binary
data frames, each frame represents one write step. The following entries in
the header are allowed, entries need to be of the form label=value:
    • version (char*) - .fm file version
    • groupname (char*) - index_array group for which forces were written out
    • writefreq (int) - output frequence (in simulation steps)
    • nsteps (int) - number of frames in the file. This is an estimate, don’t
    trust this value!
    • sysanr (int) - number of atoms in the whole system, including water
    and ions
    • fmdim (int) - dimension of the force index_matrix, what equals to the number
    of atoms for which forces were written out
    • intsize (int) - the sizeof(int) for the hardware the file was written
    on
    • realsize (int) - the sizeof(real) for the hardware the file was written
    on
-----------------------------------------------------------------------------

Data Block organisation
-----------------------------------------------------------------------------
Each of the following binary blocks contains an array of forces and the according
index_array and interaction arrays. The index_array array stores the index_array in the
force index_matrix (according to a symmetric atoms × atoms index_matrix) and the interaction
array the interaction type (bond, angle, dihedral, VdW or Coulomb).

datatype    count       description
int         1           Current write step
int         1           Number of entries in the force-index_matrix (entries)
int*        fmdim       Atom IDs of the atoms in the force index_matrix
int*        entries     The index_array array
real*       entries     The forces
char*       entries     The interaction type between each two atoms. This can be bond | angle | dihedral | Vdw | Coulomb.
int         1           Each block is closed by writing an integer with value NEW ENTRY

Interaction values: 
• bond      = 1
• angle     = 2
• dihedrals = 3
• VdW       = 5 
• Coulomb   = 6
• cumulated = 7

The n*n symmetrical index_matrix of pairwise forces will be primarily populated 
with zeroes and therefore be classified as a sparse index_matrix. The data is 
stored by SparseM in the commonly used Compressed Row Storage (CRS) format.
The whole index_matrix is used, the upper triangular part for storing VdW forces
and the lower part is allocated for Coulomb forces.

Compressed Row Storage (CRS)
-----------------------------------------------------------------------------
The Compressed Row Storage (CRS) format puts the subsequent nonzeros of the 
index_matrix rows in contiguous memory locations. Assuming we have a nonsymmetric 
sparse index_matrix, we create vectors: one for floating-point numbers (val), 
and the other two for integers (col_ind, row_ptr). The val vector stores the
values of the nonzero elements of the index_matrix, as they are traversed in a 
row-wise fashion. The col_ind vector stores the column index_arrayes of the 
elements in the val vector.
-----------------------------------------------------------------------------
%}
